<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PDF Editor - Chrome Style</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary: #1a73e8;
      --primary-dark: #1669d6;
      --secondary: #5f6368;
      --light: #f8f9fa;
      --dark: #202124;
      --gray: #5f6368;
      --gray-light: #dadce0;
      --toolbar-bg: #f1f3f4;
      --toolbar-hover: #e8eaed;
      --border-radius: 4px;
      --shadow: 0 1px 2px rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
      --transition: all 0.2s ease;
      
      /* Gap variables - centralized control */
      --page-padding: 12px;
      --column-gap: 12px;
      --row-gap: 12px;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: #f8f9fa; color: var(--dark); line-height: 1.6; overflow: hidden; height: 100vh;
    }

    .app-container { display: flex; flex-direction: column; height: 100vh; }

    .header {
      display: flex; align-items: center; justify-content: center;
      padding: 8px 16px; background: white; border-bottom: 1px solid var(--gray-light); z-index: 100; position: relative;
      /* keep header on a single row and enable horizontal scrolling when needed */
      flex-wrap: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      /* ensure the header sections don't shrink and stay inline */
      white-space: nowrap;
    }

    .header-section {
      display: flex; align-items: center; gap: 8px;
      padding: 4px 8px;
      border-right: 1px solid var(--gray-light);
      flex: 0 0 auto; /* prevent wrapping / shrinking */
      white-space: nowrap;
    }
    
    .header-section:last-child {
      border-right: none;
    }

    .header-actions { display: flex; gap: 8px; flex-wrap: wrap; }

    .main-content { display: flex; flex: 1; overflow: hidden; }

    .pdf-viewer-container { flex:1; display:flex; flex-direction:column; overflow:hidden; background:#f8f9fa;}

    /* viewer container: only vertical scroll, hide horizontal (we compute scale to avoid horizontal overflow) */
    #viewerContainer { 
      flex:1; 
      overflow-y:auto; 
      overflow-x:auto; 
      position:relative; 
      background:#f8f9fa; 
      /* move padding to container so spacing from scrollbar is the container padding */
      padding: var(--page-padding);
    }

    /* SINGLE-PAGE layout - defined first so it's easy to override */
    #viewer.single-page {
      display: flex;
      flex-direction: column;
      /* size to content so horizontal scrolling works when page is wider than container */
      width: fit-content;
      gap: var(--row-gap);
      justify-items: center;
      justify-content: center;
      /* center the viewer when its content is narrower than the container */
      margin: 0 auto;
      /* align pages to the viewer's left edge so horizontal scroll reveals both sides when wider */
      align-items: flex-start;
    }
    
    /* viewer default (for backward compatibility) */
    #viewer { 
      padding:0; 
      display:flex; 
      flex-direction:column; 
      /* keep default centered behavior for other modes, single-page overrides above */
      align-items:center;
      gap:var(--row-gap); 
    }

    .page { position:relative; margin:0; box-shadow: var(--shadow); border-radius:4px; overflow:hidden; background:white; }
    /* Prevent flexbox from shrinking the page and allow accurate horizontal scrolling */
    .page { flex: 0 0 auto; min-width: 0; box-sizing: border-box; }
    /* For single-page view: use the viewerContainer padding for left/right breathing room
       (avoid adding extra margins on the page element which can cause clipping at high zoom). */
    #viewer.single-page .page {
      margin: 0;
    }
    .textLayer { position:absolute; left:0; top:0; right:0; bottom:0; overflow:hidden; opacity:0.2; line-height:1; pointer-events:none; }
    .textLayer > span { color: transparent; position:absolute; white-space: pre; cursor:text; transform-origin: 0% 0%; }
    .textLayer .highlight { background-color: rgba(255,255,0,0.3); }

    .txt { position:absolute; padding:4px; border:1px dashed transparent; pointer-events:auto; background:transparent; white-space:pre-wrap; word-wrap:break-word; overflow:hidden; cursor:text; box-sizing:border-box; border-radius:2px; transition:var(--transition); z-index:10; font-family:Arial, sans-serif; }
    .txt[contenteditable] { outline:none; }
    .txt.selected { border-color:var(--primary); background: rgba(26,115,232,0.05); box-shadow: 0 0 0 1px var(--primary); }

    .btn { display:flex; align-items:center; justify-content:center; gap:8px; padding:8px 16px; border-radius:var(--border-radius); border:none; font-weight:500; font-size:13px; cursor:pointer; transition:var(--transition); white-space:nowrap; background:white; color:var(--dark); border:1px solid var(--gray-light); }
    .btn:hover { background: var(--toolbar-hover); }
    .btn-primary { background:var(--primary); color:white; border-color:var(--primary); }
    .btn-primary:hover { background:var(--primary-dark); border-color:var(--primary-dark); }

    .btn-icon { width:32px; height:32px; padding:0; border-radius:4px; display:flex; align-items:center; justify-content:center; background:transparent; border:none; }
    .btn-icon:hover { background:var(--toolbar-hover); }

    .file-input-wrapper { position:relative; overflow:hidden; display:inline-block; }
    .file-input-wrapper input[type=file] { position:absolute; left:0; top:0; opacity:0; width:100%; height:100%; cursor:pointer; }

    .form-group { display:flex; flex-direction:column; gap:6px; }
    .form-label { font-size:13px; font-weight:500; color:var(--dark); }
    .form-control { padding:8px 12px; border-radius:var(--border-radius); border:1px solid var(--gray-light); background:white; font-size:13px; transition:var(--transition); }
    .form-control:focus { outline:none; border-color:var(--primary); box-shadow: 0 0 0 2px rgba(26,115,232,0.2); }

    .floating-toolbar { position:absolute; display:none; background:white; border-radius:var(--border-radius); box-shadow:var(--shadow); padding:8px; gap:12px; align-items:center; z-index:1000; border:1px solid var(--gray-light); }

    .toolbar-group { display:flex; align-items:center; gap:6px; padding:0 8px; border-right:1px solid var(--gray-light); }
    .toolbar-group:last-child { border-right:none; }
    .toolbar-group button { background:none; border:1px solid transparent; border-radius:4px; padding:6px; cursor:pointer; transition:var(--transition); }
    .toolbar-group button:hover { background:var(--toolbar-hover); }

    .txt-handle-container { position:absolute; pointer-events:none; z-index:10; }
    .txt-handle { position:absolute; pointer-events:auto; }
    .txt-handle-left, .txt-handle-right { top:0; bottom:0; width:6px; cursor:ew-resize; }
    .txt-handle-left { left:-3px; }
    .txt-handle-right { right:-3px; }
    .txt-handle-top, .txt-handle-bottom { left:0; right:0; height:6px; cursor:move; }
    .txt-handle-top { top:-3px; }
    .txt-handle-bottom { bottom:-3px; }

    .zoom-controls { display:flex; align-items:center; gap:8px; }
    .zoom-btn { width:32px; height:32px; display:flex; align-items:center; justify-content:center; border-radius:4px; background:white; border:1px solid var(--gray-light); cursor:pointer; transition:var(--transition); }
    .zoom-btn:hover { background:var(--toolbar-hover); }

    /* Two-page view layout: force max 2 columns regardless of zoom */
    /* Placed after single-page so it overrides when two-page mode is active */
    #viewer.two-page {
      display: grid;
      /* Use fixed column width based on page dimensions at current scale */
      grid-template-columns: repeat(2, minmax(auto, max-content));
      grid-auto-flow: row;
      column-gap: var(--column-gap);
      row-gap: var(--row-gap);
      align-items: start;      /* top-align pages so vertical offset is consistent */
      justify-items: center;
      /* Allow horizontal scrolling when needed */
      justify-content: center;
      width: fit-content;
      margin: 0 auto;
    }
    /* Keep page intrinsic width/height (canvas will be rendered to those px) */
    #viewer.two-page .page {
      width: auto;
      margin: 0;
      align-self: start; /* ensure top alignment */
      box-sizing: border-box;
      /* Ensure minimum width to prevent overlap */
      min-width: 0;
    }

    .page-nav { display:flex; align-items:center; gap:8px; }
    .page-input { width:50px; text-align:center; padding:4px; border:1px solid var(--gray-light); border-radius:4px; font-size:13px; }
    .page-input.editable { background:white; border-color:var(--primary); }

    /* Hilangkan spinner pada input number (Chrome, Edge, Safari) */
input[type=number]::-webkit-inner-spin-button,
input[type=number]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

    @media (max-width: 1024px) { 
      /* keep the same single-row behaviour on small screens
         and ensure the left-most header items are visible by default.
         Use flex-start so the initial visible area shows the left edge,
         allow horizontal scroll when content overflows. */
      .header {
        gap: 8px;
        justify-content: flex-start;       /* show leftmost items first */
        padding-left: var(--page-padding); /* breathing room from left edge */
        -webkit-overflow-scrolling: touch;
      }
      .header-section {
        border-bottom: none;
        flex: 0 0 auto;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Header dengan semua fungsi toolbar -->
    <header class="header">
      <!-- i) Open File -->
      <div class="header-section">
        <div class="file-input-wrapper">
          <button class="btn btn-primary">
            <i class="fas fa-folder-open"></i> Open PDF
          </button>
          <input id="fileInput" type="file" accept="application/pdf" />
        </div>
      </div>
      
      <!-- ii) Add Text -->
      <div class="header-section">
        <button id="addTextBtn" class="btn">
          <i class="fas fa-font"></i> Add Text
        </button>
      </div>
      
      <!-- iii) Zoom Controls -->
      <div class="header-section">
        <button class="btn-icon" id="zoomOut" title="Zoom out">
          <i class="fas fa-search-minus"></i>
        </button>
        <button class="btn-icon" id="zoomIn" title="Zoom in">
          <i class="fas fa-search-plus"></i>
        </button>
        <!-- Readonly zoom level display -->
        <input id="zoomLevelDisplay" type="text" readonly value="100%" class="page-input" style="width:70px; margin-left:8px; text-align:center;">
        <button class="btn-icon" id="fitWidth" title="Fit to width">
          <i class="fas fa-arrows-alt-h"></i>
        </button>
        <button class="btn-icon" id="fitPage" title="Fit to page">
          <i class="fas fa-arrows-alt-v"></i>
        </button>
      </div>
      
      <!-- iv) Page Navigation -->
      <div class="header-section">
        <span class="page-nav">
          <input type="number" id="currentPageInput" class="page-input editable" value="0">
          <span style="margin: 0 4px;">of <span id="totalPagesText">0</span></span>
        </span>
      </div>
      
      <!-- v) Save -->
      <div class="header-section">
        <button id="rotateBtn" class="btn">
          <i class="fas fa-rotate-right"></i> Rotate
        </button>
      </div>
      <!-- Page View (single / two) placed to the left of Save -->
      <div class="header-section">
        <button id="singlePageViewBtn" class="btn btn-primary" title="Single page view">
          <i class="fas fa-file"></i> Single
        </button>
        <button id="twoPageViewBtn" class="btn" title="Two page view">
          <i class="fas fa-columns"></i> Two
        </button>
      </div>
       <div class="header-section">
         <button id="downloadBtn" class="btn">
           <i class="fas fa-download"></i> Save
         </button>
       </div>
    </header>

    <!-- Main Content -->
    <div class="main-content">
      <!-- PDF Viewer -->
      <main class="pdf-viewer-container">
        <div id="viewerContainer">
          <!-- set default class single-page for ease of styling -->
          <div id="viewer" class="single-page">
            <!-- PDF pages will be inserted here -->
            <div class="welcome-screen" style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; text-align:center; padding:40px;">
              <div style="font-size:64px; color:#dadce0; margin-bottom:16px;">
                <i class="fas fa-file-pdf"></i>
              </div>
              <h2 style="font-size:24px; margin-bottom:12px; color:var(--dark);">PDF Editor</h2>
              <p style="font-size:14px; color:var(--gray); max-width:400px; margin-bottom:24px;">
                Start editing by clicking 'Open PDF' in the header.
              </p>
            </div>
          </div>
        </div>
      </main>
    </div>

  <!-- Floating Toolbar -->
  <div id="floatingToolbar" class="floating-toolbar">
    <div class="toolbar-group">
      <input type="number" id="fontSizeInput" min="6" max="200" value="14" title="Font Size" class="form-control" style="width:60px;">
    </div>
    <div class="toolbar-group">
      <select id="fontFamilySelect" title="Font Family" class="form-control" style="width:100px;">
        <option value="Arial">Arial</option>
        <option value="Helvetica">Helvetica</option>
        <option value="Times New Roman">Times New Roman</option>
        <option value="Courier New">Courier New</option>
      </select>
    </div>
    <div class="toolbar-group">
      <select id="fontColorSelect" title="Font Color" class="form-control" style="width:90px;">
        <option value="#000000">Black</option>
        <option value="#1a73e8">Blue</option>
        <option value="#34a853">Green</option>
        <option value="#ea4335">Red</option>
      </select>
    </div>
    <div class="toolbar-group">
      <select id="textAlignSelect" title="Text Alignment" class="form-control" style="width:80px;">
        <option value="left">Left</option>
        <option value="center">Center</option>
        <option value="right">Right</option>
      </select>
    </div>
    <div class="toolbar-group">
      <button id="deleteTextBtn" title="Delete Text" class="btn-icon">
        <i class="fas fa-trash"></i>
      </button>
    </div>
  </div>

  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

  <script>
    // PDF Editor JavaScript dengan gaya Chrome PDF Viewer
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    const fileInput = document.getElementById('fileInput');
    const viewerContainer = document.getElementById('viewerContainer');
    const viewer = document.getElementById('viewer');
    const addTextBtn = document.getElementById('addTextBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const currentPageInput = document.getElementById('currentPageInput');
    const totalPagesText = document.getElementById('totalPagesText');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const fitWidthBtn = document.getElementById('fitWidth');
    const fitPageBtn = document.getElementById('fitPage');
    const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');
    const singlePageViewBtn = document.getElementById('singlePageViewBtn');
    const twoPageViewBtn = document.getElementById('twoPageViewBtn');
    
    const floatingToolbar = document.getElementById('floatingToolbar');
    const fontSizeInput = document.getElementById('fontSizeInput');
    const fontFamilySelect = document.getElementById('fontFamilySelect');
    const fontColorSelect = document.getElementById('fontColorSelect');
    const textAlignSelect = document.getElementById('textAlignSelect');
    const deleteTextBtn = document.getElementById('deleteTextBtn');
    const rotateBtn = document.getElementById('rotateBtn');

    let pdfDoc = null;
    let originalPdfBytes = null;
    let currentSelected = null;
    let elementIdCounter = 0;
    let currentPage = 1;
    let totalPages = 1;
    let pageCanvases = [];
    let currentScale = 1.0;
    let initialScale = 1.0; // baseline scale used for 100% display
    let currentRotation = 0; // 0,90,180,270
    let pageViewMode = 'single'; // 'single' or 'two'
    const ZOOM_FACTOR = 1.10; // 10% step (multiplicative)
    const MIN_ZOOM_PCT = 20;
    const MAX_ZOOM_PCT = 500; // maximum 200%
    let textElements = [];
    let scrollObserver = null;
    
    // Helper function to get CSS variable value
    function getCSSVariable(varName) {
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }
    
    // Helper: read first page base width/height at scale=1 with current rotation
    async function getFirstPageBaseSize() {
      let pageBaseWidth = 612, pageBaseHeight = 792;
      if (!pdfDoc) return { width: pageBaseWidth, height: pageBaseHeight };
      try {
        const firstPage = await pdfDoc.getPage(1);
        const vp = firstPage.getViewport({ scale: 1.0, rotation: currentRotation });
        pageBaseWidth = vp.width || pageBaseWidth;
        pageBaseHeight = vp.height || pageBaseHeight;
      } catch (err) {
        console.warn('getFirstPageBaseSize failed, using fallback', err);
      }
      return { width: pageBaseWidth, height: pageBaseHeight };
    }

    // Compute scale so exactly two pages fit horizontally (account gap/padding), and also respect height
    function computeTwoPageFitScale(pageBaseWidth, pageBaseHeight) {
      const columnGap = parseFloat(getCSSVariable('--column-gap')) || 12;
      // Use container paddings (viewerContainer) because container holds the scrollbar and padding
      const containerStyle = window.getComputedStyle(viewerContainer);
      const containerPaddingH = (parseFloat(containerStyle.paddingLeft) || 0) + (parseFloat(containerStyle.paddingRight) || 0);

      const containerWidth = Math.max(1, viewerContainer.clientWidth - containerPaddingH);
      const containerHeight = Math.max(1, viewerContainer.clientHeight - ((parseFloat(containerStyle.paddingTop)||0) + (parseFloat(containerStyle.paddingBottom)||0)));

      const scaleW = (containerWidth - columnGap) / (pageBaseWidth * 2);
      const scaleH = containerHeight / pageBaseHeight;
      return scaleW;
    }

    // Set page view mode and ensure maximum two columns. Do not allow more-than-two columns by using fixed grid.
    async function setPageView(mode) {
      pageViewMode = mode === 'two' ? 'two' : 'single';

      if (pageViewMode === 'two') {
        viewer.classList.add('two-page');
        viewer.classList.remove('single-page');
        singlePageViewBtn.classList.remove('btn-primary');
        twoPageViewBtn.classList.add('btn-primary');
      } else {
        viewer.classList.add('single-page');
        viewer.classList.remove('two-page');
        twoPageViewBtn.classList.remove('btn-primary');
        singlePageViewBtn.classList.add('btn-primary');
      }

      if (!pdfDoc) {
        initScrollObserver();
        return;
      }

      try {
        const base = await getFirstPageBaseSize();
        const minScale = (MIN_ZOOM_PCT / 100);
        const maxScale = (MAX_ZOOM_PCT / 100);

        if (pageViewMode === 'two') {
          let target = computeTwoPageFitScale(base.width, base.height);
          target = Math.max(minScale, Math.min(maxScale, target));
          await setScale(target);
          viewer.style.setProperty('--two-page-justify', 'center');
        } else {
          // SINGLE: compute fit-to-width based on viewerContainer inner width (respect padding & edge gap)
          const containerStyle = window.getComputedStyle(viewerContainer);
          const containerPaddingH = (parseFloat(containerStyle.paddingLeft) || 0) + (parseFloat(containerStyle.paddingRight) || 0);
          const containerWidth = Math.max(1, viewerContainer.clientWidth - containerPaddingH);
          const edgeGap = parseFloat(getCSSVariable('--page-padding')) || 12;
          const containerWidthForScale = Math.max(1, containerWidth - edgeGap);

          let singleScale = containerWidthForScale / base.width;
          singleScale = Math.max(minScale, Math.min(maxScale, singleScale));
          await setScale(singleScale);

          viewer.style.setProperty('--two-page-justify', 'center');
        }
      } catch (err) {
        console.warn('setPageView fallback render', err);
        await renderAllPages();
      }

      initScrollObserver();
    }

    // Event Listeners
    fileInput.addEventListener('change', handleFileSelect);
    
    addTextBtn.addEventListener('click', addText);

    function addText() {
      if (!pdfDoc) {
        return alert('Please upload a PDF first.');
      }
      
      // Find the first page to add text to
      const firstPage = document.querySelector('.page');
      if (!firstPage) return;
      
      const pageRect = firstPage.getBoundingClientRect();
      const viewerRect = viewer.getBoundingClientRect();
      
      const x = 50; // Default x position
      const y = 50; // Default y position
      
      const el = createTextElement('New text', x, y, 14, 'Arial', '#000000', 'left');
      
      // Position the text element relative to the page
      el.style.position = 'absolute';
      el.style.left = `${pageRect.left - viewerRect.left + x}px`;
      el.style.top = `${pageRect.top - viewerRect.top + y}px`;
      el.style.zIndex = '10';
      
      // Store page number for this text element
      el.dataset.page = 1;
      
      viewer.appendChild(el);
      textElements.push(el);
      selectElement(el);
      updateTextBoxSize(el);
    }

    downloadBtn.addEventListener('click', async () => {
      if (!originalPdfBytes) return alert('Please upload a PDF first.');
      alert('Export functionality would be implemented here with pdf-lib');
    });

    // Handle current page input changes
    currentPageInput.addEventListener('change', () => {
      if (!pdfDoc) return;
      
      let pageNum = parseInt(currentPageInput.value);
      if (isNaN(pageNum) || pageNum < 1) pageNum = 1;
      if (pageNum > totalPages) pageNum = totalPages;
      
      currentPage = pageNum;
      updatePageInfo();
      scrollToPage(currentPage);
    });

    // Zoom controls
    // Unified scale setter: preserves scroll, scales text overlays, re-renders pages and restores UI
    async function setScale(newScale) {
      if (!pdfDoc) return;
      const oldScale = currentScale;
      // clamp to absolute min/max (1.0 == 100%)
      const minScale = (MIN_ZOOM_PCT / 100);
      const maxScale = (MAX_ZOOM_PCT / 100);
      newScale = Math.max(minScale, Math.min(maxScale, newScale));
      // avoid tiny float diffs
      if (Math.abs(oldScale - newScale) < 1e-6) return;
 
       // save UI state
       const prevScrollTop = viewerContainer.scrollTop;
       const prevScrollLeft = viewerContainer.scrollLeft;
       const selectedId = currentSelected && currentSelected.dataset && currentSelected.dataset.id;
 
       // scale text overlay positions & sizes by ratio so they keep relative positions
       const ratio = newScale / oldScale;
       textElements.forEach(el => {
         const left = parseFloat(el.style.left) || 0;
         const top = parseFloat(el.style.top) || 0;
         const width = parseFloat(el.style.width) || el.offsetWidth;
         const height = parseFloat(el.style.height) || el.offsetHeight;
         const fontSize = parseFloat(el.dataset.fontSize) || parseFloat(window.getComputedStyle(el).fontSize) || 14;
 
         el.style.left = (left * ratio) + 'px';
         el.style.top = (top * ratio) + 'px';
         el.style.width = (width * ratio) + 'px';
         el.style.height = (height * ratio) + 'px';
 
         const newFont = Math.max(6, fontSize * ratio);
         el.style.fontSize = newFont + 'px';
         el.dataset.fontSize = newFont;
       });
 
       currentScale = newScale;
       updateZoomDisplay();
       await renderAllPages(oldScale); // pass oldScale so renderAllPages dapat adjust scroll correctly
 
       // restore scroll/selection/observer
       viewerContainer.scrollTop = prevScrollTop;
       viewerContainer.scrollLeft = prevScrollLeft;
       if (selectedId) {
        const sel = textElements.find(e => e.dataset.id === selectedId);
        if (sel) selectElement(sel);
      }
      initScrollObserver();
     updateScrollBehavior();
     }
 
    function getCurrentDisplayPct() {
      // Peratus kini berdasarkan currentScale terus (1.0 = 100%)
      return Math.round(currentScale * 100);
    }

    zoomInBtn.addEventListener('click', () => {
      if (!pdfDoc) return;
      const curPct = getCurrentDisplayPct();
      const newPct = Math.min(MAX_ZOOM_PCT, curPct + 10); // +10 percentage points
      const newScale = (initialScale || 1.0) * (newPct / 100);
      setScale(newScale);
    });

    zoomOutBtn.addEventListener('click', () => {
      if (!pdfDoc) return;
      const curPct = getCurrentDisplayPct();
      const newPct = Math.max(MIN_ZOOM_PCT, curPct - 10); // -10 percentage points
      const newScale = (initialScale || 1.0) * (newPct / 100);
      setScale(newScale);
    });
 
    fitWidthBtn.addEventListener('click', () => {
      if (pdfDoc) {
        (async () => {
          if (pageViewMode === 'two') {
            const base = await getFirstPageBaseSize();
            const twoScale = computeTwoPageFitScale(base.width, base.height);
            const minScale = (MIN_ZOOM_PCT / 100);
            const maxScale = (MAX_ZOOM_PCT / 100);
            setScale(Math.max(minScale, Math.min(maxScale, twoScale)));
          } else {
            // single page: compute fit-to-width but leave a small edge gap so it won't touch scrollbar
            const containerStyle = window.getComputedStyle(viewerContainer);
            const containerPaddingH = (parseFloat(containerStyle.paddingLeft) || 0) + (parseFloat(containerStyle.paddingRight) || 0);
            const containerWidth = Math.max(1, viewerContainer.clientWidth - containerPaddingH);
            const edgeGap = parseFloat(getCSSVariable('--page-padding')) || 12;
            const containerWidthForScale = Math.max(1, containerWidth - edgeGap);
            const firstPage = await pdfDoc.getPage(1);
            const vp = firstPage.getViewport({ scale: 1.0, rotation: currentRotation });
            const pageBaseWidth = vp.width || 612;
            const singleScale = containerWidthForScale / pageBaseWidth;
            const minScale = (MIN_ZOOM_PCT / 100);
            const maxScale = (MAX_ZOOM_PCT / 100);
            setScale(Math.max(minScale, Math.min(maxScale, singleScale)));
          }
        })();
      }
    });

    fitPageBtn.addEventListener('click', () => {
      if (pdfDoc) {
        (async () => {
          try {
            // Get gap values from CSS variables
            const columnGap = parseFloat(getCSSVariable('--column-gap')) || 20;
            // compute container inner size from computed style (accounts for padding)
            const containerStyle = window.getComputedStyle(viewerContainer);
            const containerPaddingH = (parseFloat(containerStyle.paddingLeft) || 0) + (parseFloat(containerStyle.paddingRight) || 0);
            const containerPaddingV = (parseFloat(containerStyle.paddingTop) || 0) + (parseFloat(containerStyle.paddingBottom) || 0);
            const containerWidth = Math.max(1, viewerContainer.clientWidth - containerPaddingH);
            const containerHeight = Math.max(1, viewerContainer.clientHeight - containerPaddingV);

            const firstPage = await pdfDoc.getPage(1);
            const vp = firstPage.getViewport({ scale: 1.0, rotation: currentRotation });
            const pageBaseWidth = vp.width || 612;
            const pageBaseHeight = vp.height || 792;
            let targetScale;
            if (pageViewMode === 'two') {
              // ensure two pages side-by-side fit fully (horizontal and vertical)
              const scaleW = (containerWidth - columnGap) / (pageBaseWidth * 2);
              const scaleH = containerHeight / pageBaseHeight;
              targetScale = Math.min(scaleW, scaleH);
            } else {
              targetScale = Math.min(containerWidth / pageBaseWidth, containerHeight / pageBaseHeight);
            }
            // clamp to allowed min/max
            const minScale = (MIN_ZOOM_PCT / 100);
            const maxScale = (MAX_ZOOM_PCT / 100);
            targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
            setScale(targetScale);
          } catch (err) {
            // fallback simple fit
            // compute container paddings for fallback as well
            const containerStyle = window.getComputedStyle(viewerContainer);
            const containerPaddingH = (parseFloat(containerStyle.paddingLeft) || 0) + (parseFloat(containerStyle.paddingRight) || 0);
            const containerPaddingV = (parseFloat(containerStyle.paddingTop) || 0) + (parseFloat(containerStyle.paddingBottom) || 0);
            const containerWidth = Math.max(1, viewerContainer.clientWidth - containerPaddingH);
            const containerHeight = Math.max(1, viewerContainer.clientHeight - containerPaddingV);
            setScale(Math.min(containerWidth / 612, containerHeight / 792));
          }
        })();
      }
    });

    // Floating toolbar event listeners
    fontSizeInput.addEventListener('change', () => {
      if (currentSelected) {
        currentSelected.style.fontSize = fontSizeInput.value + 'px';
        currentSelected.dataset.fontSize = fontSizeInput.value;
        updateTextBoxSize(currentSelected);
      }
    });

    fontFamilySelect.addEventListener('change', () => {
      if (currentSelected) {
        currentSelected.style.fontFamily = fontFamilySelect.value;
        currentSelected.dataset.fontFamily = fontFamilySelect.value;
        updateTextBoxSize(currentSelected);
      }
    });

    fontColorSelect.addEventListener('change', () => {
      if (currentSelected) {
        currentSelected.style.color = fontColorSelect.value;
        currentSelected.dataset.color = fontColorSelect.value;
      }
    });

    textAlignSelect.addEventListener('change', () => {
      if (currentSelected) {
        currentSelected.style.textAlign = textAlignSelect.value;
        currentSelected.dataset.textAlign = textAlignSelect.value;
        updateTextBoxSize(currentSelected);
      }
    });

    deleteTextBtn.addEventListener('click', () => {
      if (currentSelected) {
        const index = textElements.indexOf(currentSelected);
        if (index > -1) {
          textElements.splice(index, 1);
        }
        currentSelected.remove();
        currentSelected = null;
        hideFloatingToolbar();
      }
    });

    singlePageViewBtn && singlePageViewBtn.addEventListener('click', () => setPageView('single'));
    twoPageViewBtn && twoPageViewBtn.addEventListener('click', () => setPageView('two'));

    // File handling
    async function handleFileSelect(e) {
      const f = e.target.files[0];
      if (!f) return;
      originalPdfBytes = await f.arrayBuffer();
      
      try {
        await loadAndRenderPdf(originalPdfBytes);
      } catch (error) {
        console.error("Failed to load or render PDF:", error);
        alert("Failed to load PDF. Please check the console for errors.");
      }
    }

    // PDF rendering
    async function loadAndRenderPdf(pdfBytes) {
      // Clear any existing content
      const welcomeScreen = viewer.querySelector('.welcome-screen');
      if (welcomeScreen) {
        welcomeScreen.remove();
      }
      
      viewer.innerHTML = '';
      pageCanvases = [];
      textElements = [];
      
      // Load the PDF document
      pdfDoc = await pdfjsLib.getDocument({data: pdfBytes}).promise;
      totalPages = pdfDoc.numPages;
      
      // Reset to first page
      currentPage = 1;
      updatePageInfo();

      // Get gap values from CSS variables
      const pagePadding = parseFloat(getCSSVariable('--page-padding')) || 12;
      // container width is computed later from computed style to include actual padding/scrollbar,
      // so don't declare it twice here.
      // const containerWidth = viewerContainer.clientWidth - (pagePadding * 2);
      
      // compute actual page width at scale=1 with current rotation so baseline (fit-to-width) shows 100%
      let pageBaseWidth = 612; // fallback common PDF page width
      try {
        const firstPageForScale = await pdfDoc.getPage(1);
        const vp = firstPageForScale.getViewport({ scale: 1.0, rotation: currentRotation });
        pageBaseWidth = vp.width || pageBaseWidth;
      } catch (err) {
        console.warn('Could not read first page for baseline width, using fallback', err);
      }
      // Compute container inner width properly by subtracting container paddings (read from computed style)
      const containerStyle = window.getComputedStyle(viewerContainer);
      const containerPaddingH = (parseFloat(containerStyle.paddingLeft) || 0) + (parseFloat(containerStyle.paddingRight) || 0);
      // subtract a small edge gap for single-page fit so page doesn't sit flush to scrollbar
      const edgeGap = parseFloat(getCSSVariable('--page-padding')) || 12;
      const containerWidth = Math.max(1, viewerContainer.clientWidth - containerPaddingH);
      const containerWidthForScale = Math.max(1, containerWidth - edgeGap);
      initialScale = (containerWidthForScale / pageBaseWidth) || 1.0;
      // Tetapkan currentScale terus ke fit-to-width (buang konsep baseline 100%)
      initialScale = 1.0; // kekalkan variable untuk backward compat jika perlu
      currentScale = (containerWidthForScale / pageBaseWidth) || 1.0;
      updateZoomDisplay();
      
      // Render all pages
      await renderAllPages();
     updateScrollBehavior();
      
      // Initialize scroll observer to track current page
      initScrollObserver();
      // apply current page view (preserve user choice across loads)
      await setPageView(pageViewMode);
    }
    
    function updateZoomDisplay() {
      if (!zoomLevelDisplay) return;
      if (!pdfDoc) {
        zoomLevelDisplay.value = '100%';
        return;
      }
      // Tunjukkan peratus berdasarkan currentScale terus
      const pct = Math.round(currentScale * 100);
      zoomLevelDisplay.value = pct + '%';
    }

    // Render pages without blanking viewer to avoid flashing.
    // If oldScale is provided we use it to compute scroll restore ratio.
    async function renderAllPages(oldScale) {
      const prevCenter = viewerContainer.scrollTop + viewerContainer.clientHeight / 2;
      const oldScaleVal = (typeof oldScale === 'number' && oldScale > 0) ? oldScale : currentScale;

      // keep existing pages while rendering new ones to avoid blank screen
      const oldPages = Array.from(viewer.querySelectorAll('.page'));
      const fragment = document.createDocumentFragment();
      const newPageRecords = [];

      for (let i = 1; i <= totalPages; i++) {
        const pageDiv = await renderPageToFragment(i);
        fragment.appendChild(pageDiv);
        newPageRecords.push(pageDiv);
      }

      // Insert new pages at the top (so textElements stay on top if they are appended later)
      viewer.insertBefore(fragment, viewer.firstChild);

      // Remove old pages after new are inserted
      oldPages.forEach(p => p.remove());

      // Update pageCanvases mapping
      pageCanvases = newPageRecords.map(div => ({
        canvas: div.querySelector('canvas'),
        textLayer: div.querySelector('.textLayer'),
        pageIndex: parseInt(div.dataset.pageNum, 10) - 1
      }));

      // If two-page mode, ensure proper spacing to prevent overlap
      if (pageViewMode === 'two' && pageCanvases.length > 0) {
        try {
          // Get gap values from CSS variables
          const columnGap = parseFloat(getCSSVariable('--column-gap')) || 20;
          
          // Let CSS handle centering / overflow; keep only visual adjustments here
          viewer.style.setProperty('--two-page-justify', 'center');
        } catch (e) {
          viewer.style.setProperty('--two-page-justify', 'center');
        }
      } else {
        viewer.style.removeProperty('--two-page-column-width');
      }
      // NOTE: scrollbar behaviour is controlled entirely by CSS now
     // Update scroll behavior (enable horizontal scroll when content wider than container)
     updateScrollBehavior();
    }
    
    // Toggle horizontal scrolling handled by CSS only — make this a no-op in JS
    function updateScrollBehavior() {
      // Intentionally empty: scrollbar behavior controlled by CSS (#viewerContainer { overflow-x:auto; overflow-y:auto; })
    }
 
    // Render a single page but return element (do not append to viewer)
    async function renderPageToFragment(pageNum) {
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale: currentScale, rotation: currentRotation });

      const pageDiv = document.createElement('div');
      pageDiv.className = 'page';
      pageDiv.style.width = viewport.width + 'px';
      pageDiv.style.height = viewport.height + 'px';
      pageDiv.dataset.pageNum = pageNum;

      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = viewport.width;
      canvas.height = viewport.height;

      const textLayer = document.createElement('div');
      textLayer.className = 'textLayer';
      textLayer.style.width = viewport.width + 'px';
      textLayer.style.height = viewport.height + 'px';

      pageDiv.appendChild(canvas);
      pageDiv.appendChild(textLayer);

      // Render PDF page to canvas
      const renderContext = { canvasContext: context, viewport: viewport };
      await page.render(renderContext).promise;

      // Render text layer (best effort)
      try {
        const textContent = await page.getTextContent();
        if (textContent && textContent.items && textContent.items.length > 0) {
          await pdfjsLib.renderTextLayer({
            textContent,
            container: textLayer,
            viewport,
            textDivs: []
          }).promise;
        }
      } catch (err) {
        console.warn('Text layer render failed for page', pageNum, err);
      }
 
      // no inline margin here — CSS controls single / two-page layouts
      return pageDiv;
     }

    rotateBtn && rotateBtn.addEventListener('click', async () => {
      if (!pdfDoc) return;
      // Keep same absolute percent zoom after rotation (1.0 = 100%)
      const displayPct = Math.round(currentScale * 100);
      currentRotation = (currentRotation + 90) % 360;
      // preserve percent but clamp to allowed range
      currentScale = Math.max((MIN_ZOOM_PCT/100), Math.min((MAX_ZOOM_PCT/100), displayPct / 100));
      updateZoomDisplay();
      await renderAllPages();
      updateScrollBehavior();
      initScrollObserver();
    });

    function updatePageInfo() {
      if (pdfDoc) {
        currentPageInput.value = currentPage;
        totalPagesText.textContent = totalPages;
      }
    }

    function scrollToPage(pageNum) {
      const pages = document.querySelectorAll('.page');
      if (pages.length >= pageNum) {
        const page = pages[pageNum - 1];
        page.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    // Initialize Intersection Observer to track current page while scrolling
    function initScrollObserver() {
      if (scrollObserver) {
        scrollObserver.disconnect();
      }
      
      scrollObserver = new IntersectionObserver((entries) => {
        let mostVisiblePage = currentPage;
        let maxVisibility = 0;
        
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const pageNum = parseInt(entry.target.dataset.pageNum);
            const visibility = entry.intersectionRatio;
            
            if (visibility > maxVisibility) {
              maxVisibility = visibility;
              mostVisiblePage = pageNum;
            }
          }
        });
        
        if (mostVisiblePage !== currentPage) {
          currentPage = mostVisiblePage;
          updatePageInfo();
        }
      }, {
        threshold: [0.1, 0.5, 0.9],
        root: viewerContainer
      });
      
      // Observe all pages
      document.querySelectorAll('.page').forEach(page => {
        scrollObserver.observe(page);
      });
    }

    function deselectAll() {
      document.querySelectorAll('.txt').forEach(el => el.classList.remove('selected'));
      document.querySelectorAll('.txt-handle-container').forEach(el => el.remove());
      currentSelected = null;
      hideFloatingToolbar();
    }

    function createTextElement(text, x = 10, y = 10, size = 14, font = 'Arial', color = '#000000', align = 'left') {
      const div = document.createElement('div');
      div.className = 'txt';
      div.contentEditable = true;
      div.innerText = text;
      div.style.left = x + 'px';
      div.style.top = y + 'px';
      div.style.fontSize = size + 'px';
      div.style.fontFamily = font;
      div.style.color = color;
      div.style.textAlign = align;
      div.dataset.fontFamily = font;
      div.dataset.fontSize = size;
      div.dataset.color = color;
      div.dataset.textAlign = align;
      div.dataset.id = 'txt-' + (elementIdCounter++);
      
      div.addEventListener('mousedown', (ev) => {
        ev.stopPropagation();
        selectElement(div);
      });
      
      div.addEventListener('dblclick', (ev) => {
        ev.stopPropagation();
        div.focus();
      });
      
      div.addEventListener('focusout', () => {
        updateDatasetFromStyle(div);
      });
      
      div.addEventListener('input', () => {
        updateTextBoxSize(div);
      });
      
      return div;
    }

    function selectElement(el) {
      deselectAll();
      el.classList.add('selected');
      currentSelected = el;
      createHandles(el);
      showFloatingToolbar(el);
    }

    function showFloatingToolbar(el) {
      // Update toolbar values based on selected element
      fontSizeInput.value = parseInt(window.getComputedStyle(el).fontSize) || el.dataset.fontSize || 14;
      fontFamilySelect.value = el.dataset.fontFamily || 'Arial';
      fontColorSelect.value = el.dataset.color || '#000000';
      textAlignSelect.value = el.dataset.textAlign || 'left';
      
      // Position the toolbar
      const textRect = el.getBoundingClientRect();
      const toolbarRect = floatingToolbar.getBoundingClientRect();
      const spaceAbove = textRect.top;
      const spaceBelow = window.innerHeight - textRect.bottom;
      
      // Position toolbar above or below the text element
      let topPosition;
      if (spaceAbove > toolbarRect.height + 10) {
        topPosition = textRect.top + window.scrollY - toolbarRect.height - 10;
      } else {
        topPosition = textRect.bottom + window.scrollY + 10;
      }
      
      floatingToolbar.style.top = `${topPosition}px`;
      floatingToolbar.style.left = `${textRect.left + window.scrollX}px`;
      floatingToolbar.style.display = 'flex';
    }

    function hideFloatingToolbar() {
      floatingToolbar.style.display = 'none';
    }

    function createHandles(el) {
      document.querySelectorAll('.txt-handle-container').forEach(handle => handle.remove());
      
      const handleContainer = document.createElement('div');
      handleContainer.className = 'txt-handle-container';
      const rect = el.getBoundingClientRect();
      const parentRect = el.parentElement.getBoundingClientRect();
      handleContainer.style.left = (rect.left - parentRect.left) + 'px';
      handleContainer.style.top = (rect.top - parentRect.top) + 'px';
      handleContainer.style.width = el.offsetWidth + 'px';
      handleContainer.style.height = el.offsetHeight + 'px';
      
      const handles = [
        { class: 'txt-handle-left', action: 'resize-left' },
        { class: 'txt-handle-right', action: 'resize-right' },
        { class: 'txt-handle-top', action: 'move' },
        { class: 'txt-handle-bottom', action: 'move' }
      ];
      
      handles.forEach(h => {
        const handle = document.createElement('div');
        handle.className = `txt-handle ${h.class}`;
        handle.dataset.action = h.action;
        handleContainer.appendChild(handle);
      });

      el.parentNode.appendChild(handleContainer);
      makeHandlesInteractive(handleContainer, el);
    }

    function makeHandlesInteractive(container, textElement) {
      const handles = container.querySelectorAll('.txt-handle');
      let isDragging = false;
      let isResizing = false;
      let startX, startY, startLeft, startTop, startWidth, startHeight;
      let action = '';

      handles.forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          e.preventDefault();
          
          action = e.target.dataset.action;
          startX = e.clientX;
          startY = e.clientY;
          startLeft = parseFloat(textElement.style.left) || 0;
          startTop = parseFloat(textElement.style.top) || 0;
          startWidth = textElement.offsetWidth;
          startHeight = textElement.offsetHeight;
          
          if (action.startsWith('resize')) {
            isResizing = true;
          } else if (action === 'move') {
            isDragging = true;
          }
          
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        });
      });
      
      function handleMouseMove(e) {
        if (!isDragging && !isResizing) return;
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        if (isDragging) {
          textElement.style.left = (startLeft + dx) + 'px';
          textElement.style.top = (startTop + dy) + 'px';
        } else if (isResizing) {
          switch (action) {
            case 'resize-left':
              textElement.style.width = Math.max(50, startWidth - dx) + 'px';
              textElement.style.left = (startLeft + dx) + 'px';
              break;
            case 'resize-right':
              textElement.style.width = Math.max(50, startWidth + dx) + 'px';
              break;
          }
        }
        
        container.style.left = textElement.style.left;
        container.style.top = textElement.style.top;
        container.style.width = textElement.offsetWidth + 'px';
        container.style.height = textElement.offsetHeight + 'px';
        
        // Update floating toolbar position when moving/resizing
        if (currentSelected === textElement) {
          showFloatingToolbar(textElement);
        }
      }
      
      function handleMouseUp() {
        isDragging = false;
        isResizing = false;
        action = '';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      }
    }

    function updateDatasetFromStyle(el) {
      el.dataset.fontFamily = el.style.fontFamily || el.dataset.fontFamily;
      el.dataset.fontSize = parseInt(el.style.fontSize) || el.dataset.fontSize;
      el.dataset.color = el.style.color || el.dataset.color;
      el.dataset.textAlign = el.style.textAlign || el.dataset.textAlign;
    }

    function updateTextBoxSize(el) {
      const measurer = document.createElement('div');
      const computedStyle = window.getComputedStyle(el);
      measurer.style.fontSize = computedStyle.fontSize;
      measurer.style.fontFamily = computedStyle.fontFamily;
      measurer.style.fontWeight = computedStyle.fontWeight;
      measurer.style.lineHeight = computedStyle.lineHeight;
      measurer.style.whiteSpace = 'pre-wrap';
      measurer.style.wordWrap = 'break-word';
      measurer.style.padding = computedStyle.padding;
      measurer.style.border = computedStyle.border;
      measurer.style.width = 'auto';
      measurer.style.height = 'auto';
      measurer.style.position = 'absolute';
      measurer.style.visibility = 'hidden';
      measurer.style.boxSizing = 'border-box';
      measurer.style.textAlign = computedStyle.textAlign;
      measurer.textContent = el.innerText;
      document.body.appendChild(measurer);
      const width = measurer.offsetWidth;
      const height = measurer.offsetHeight;
      el.style.width = width + 'px';
      el.style.height = height + 'px';
      document.body.removeChild(measurer);
      
      if (currentSelected === el) {
        const handleContainer = document.querySelector('.txt-handle-container');
        if (handleContainer) {
          handleContainer.style.width = el.style.width;
          handleContainer.style.height = el.style.height;
        }
        showFloatingToolbar(el);
      }
    }
    // Ensure header left-most area is visible on small screens when header overflows
    (function ensureHeaderShowsLeft() {
     const headerEl = document.querySelector('.header');
     if (!headerEl) return;
     function setLeftIfOverflow() {
       if (headerEl.scrollWidth > headerEl.clientWidth) {
         headerEl.scrollLeft = 0;
       }
     }
     window.addEventListener('resize', setLeftIfOverflow);
     window.addEventListener('orientationchange', setLeftIfOverflow);
     window.addEventListener('load', () => setTimeout(setLeftIfOverflow, 50));
     // If header content changes, ensure left-most remains visible
     new MutationObserver(setLeftIfOverflow).observe(headerEl, { childList: true, subtree: true, attributes: true });
   })();
  </script>
</body>
</html>